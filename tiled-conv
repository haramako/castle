#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'pp'
require 'json'
require_relative 'rle'
require 'erb'

# 8KBごとのバンクに分けられたバッファ
class BankedBuffer

  def initialize
    @buf = []
  end

  def add( data )
    cur = @buf.size
    @buf.concat data.flatten
    cur
  end

  def bin
    @buf.pack('c*')
  end

end

class TiledConverter

  AREA_WIDTH = 16
  AREA_HEIGHT = 15

  ENEMY_TYPE = {slime:1, wow:2}

  def initialize( filename )
    data = JSON.parse( File.read(filename) )

    w = data['width'].to_i
    h = data['height'].to_i
    raise if w % AREA_WIDTH != 0 or h % AREA_HEIGHT != 0
    @buf = BankedBuffer.new
    @world_width = w / AREA_WIDTH
    @world_height = h / AREA_HEIGHT

    conv_map( data )
    conv_item( data )

    print ERB.new(DATA.read).result(binding)

    open('md.bin','wb'){|f| f.write @buf.bin }
  end

  def conv_map( data )
    aw = @world_width 
    ah = @world_height
    # pp aw, ah
    a = Array.new(@world_width*@world_height*AREA_WIDTH*AREA_HEIGHT)
    layers = data['layers'].select{|x| x['type'] == 'tilelayer'}.reverse
    a.size.times do |i|
      l = layers.find{|layer| layer['data'][i] != 0 }
      raise "Invalid map data" unless l
      a[i] = l['data'][i] - 1
    end

    addr = []
    ah.times do |ay|
      aw.times do |ax|
        d = []
        15.times do |cy|
          16.times do |cx|
            d[cy*16+cx] = a[(ay*15+cy)*AREA_WIDTH*@world_width + (ax*16+cx)]
          end
        end
        addr << @buf.add( rle_compress( d ) )
      end
    end
    @tile_addr = addr
  end

  def px2area( x, y )
    area = (y.to_i/16/AREA_HEIGHT)*@world_width + x.to_i/16/AREA_WIDTH
    cx = (x/16)%AREA_WIDTH
    cy = (y/16)%AREA_HEIGHT
    [area, cx, cy]
  end

  def conv_item( data )
    objs = data['layers'].find{|x| x['name'] == 'objects'}
    checkpoints = []
    enemy = Array.new(@world_width*@world_height){[]}
    objs['objects'].each do |obj|
      prop = obj['properties']
      case obj['type']
      when 'checkpoint'
        area, x, y = px2area( obj['x'], obj['y'] )
        checkpoints[prop['id'].to_i] = {name:obj['name'], area:area, x:x*16, y:y*16}
      when 'enemy'
        area, x, y = px2area( obj['x'], obj['y'] )
        enemy[area] << {type:prop['type'], x:x, y:y, p1:prop['p1'].to_i, p2:prop['p2'].to_i }
      end
    end

    cp_addr = []
    checkpoints.each.with_index do |cp,i|
      cp_addr << @buf.add( [ cp[:area], cp[:x], cp[:y], cp[:name].unpack('c*'), 0] )
    end


    en_addr = []
    enemy.each.with_index do |area,i|
      area = area.map do |en| 
        type = ENEMY_TYPE[ en[:type].downcase.to_sym ]
        [type, en[:x], en[:y], en[:p1] % 256, en[:p2] % 256]
      end
      en_addr << @buf.add( [area.size] + area )
    end

    @checkpoint_addr = cp_addr
    @enemy_addr = en_addr
  end

end

if ARGV.empty?
  puts "Convert Tiled json file to binary."
  puts "usage: ./tile-conv <mapfile.json>"
  exit
end

TiledConverter.new( ARGV[0] )

__END__
options(bank:1);
use en_types;
const MAP_WIDTH = <%=@world_width%>;
const MAP_HEIGHT = <%=@world_height%>;
const MAP:uint16[] = <%=@tile_addr%>;
const MAP_CHECKPOINT_NUM = <%=@checkpoint_addr.size%>;
const MAP_CHECKPOINT:uint16[] = <%=@checkpoint_addr%>;
const MAP_ENEMY:uint16[] = <%=@enemy_addr%>;
