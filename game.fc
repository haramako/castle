options( bank:0 );

use * from common;
use menu;
use en;
use my;
use debug_menu;
use event;
use mem;

const PALLET:int[] = incbin("res/character.chr.dat");

function init_area_enemy():void
{
	anim = 0;
	en.clear();
	
	var n = 0;
	for( n, 0, bg.enemy_num ){
		var idx = n*6;
		var type = bg.enemy[idx];
		var i = en.new();
		if( type & 128 ){
			en.type[i] = en.TYPE_PORTAL;
			en.p4[i] = type & 127;
		}else{
			en.type[i] = type;
		}
		en.px[i] = bg.enemy[idx+1] * 16 + 8;
		en.py[i] = bg.enemy[idx+2] * 16 + 8;
		en.p1[i] = bg.enemy[idx+3];
		en.p2[i] = bg.enemy[idx+4];
		en.p3[i] = bg.enemy[idx+5];
		en.NEW_FUNC[en.type[i]](i);
	}
}


function start(): void
{
	// ppu lock状態で入ってくる
	
	mmc3.set_cbank( 0, CBANK_BG_COMMON );
	mmc3.set_cbank( 1, CBANK_BG );
	mmc3.set_cbank( 2, CBANK_SPRITE+0 );
	mmc3.set_cbank( 3, CBANK_SPRITE+1 );
	mmc3.set_cbank( 4, CBANK_SPRITE+2 );
	mmc3.set_cbank( 5, CBANK_SPRITE+3 );
	
	ppu.ctrl1_bak = 0b10100000;
	ppu.ctrl2_bak = 0b00011110;
	ppu.scroll1 = 0;
	ppu.scroll2 = 0;
	
	// パレットの初期化
	ppu.put_in_lock( 0x3f00, fs.PAL_SET, 16 );
	mem.copy( bg.pallet, fs.PAL_SET, 16 );
	ppu.put_in_lock( 0x3f10, &PALLET[16], 16 );
	mem.copy( &bg.pallet[16], &PALLET[16], 16 );
	
	move_checkpoint(0);
	my.set_map( bg.cur_area%16, bg.cur_area/16 );

	ppu.unlock();
	
	asm( "cli" );

	anim = 0;

	while( 1 ){
		anim += 1;
		giff = GIFF_TABLE[anim%16];
		
		pad.update();
		en.process();
		my.process();
		my.draw();

		mmc3.set_cbank(0,CBANK_BG_COMMON+(anim/8)%4*2);
		ppu.wait_vsync();

		// 死亡
		if( my.state == my.STATE_DIE ){
			move_to_last();
		}

		// スクロール
		var scroll_dir = -1;
		if( my.x < 8 ){
			scroll_dir = DIR_LEFT;
		}elsif( my.x >= 248 ){
			scroll_dir = DIR_RIGHT;
		}elsif( my.y >= 232 ){
			scroll_dir = DIR_DOWN;
		}elsif( my.y < 8 ){
			if( my.state == my.STATE_LADDER ){
				scroll_dir = DIR_UP;
			}else{
				my.y = 8;
			}
		}
		if( scroll_dir != -1 ){
			bg.scroll( scroll_dir );
			set_last();
			init_area_enemy();
			my.set_map( bg.cur_area%16, bg.cur_area/16 );
		}

		// イベント
		if( game_event ){
			switch( game_event ){
			case event.ID_GET_ITEM:
				var old_pbank = mmc3.set_pbank(1, PBANK_EVENT);
				event.event_start();
				mmc3.set_pbank(1, old_pbank);
			case event.ID_MOVE_AREA:
				move_area(game_event_p1);
			case event.ID_MOVE_CHECKPOINT:
				move_checkpoint(game_event_p1);
			}
			game_event = 0;
		}
		
		// メニュー
		if( pad.pushed & pad.START ){
			var old = mmc3.set_pbank( 1, PBANK_DEBUG_MENU );
			debug_menu.start();
			mmc3.set_pbank( 1, old );
		}elsif( pad.pushed & pad.SELECT ){
			var old_bank = mmc3.set_pbank(1, PBANK_MENU);
			menu.start();
			mmc3.set_pbank( 1, old_bank );
		}
	}
  
}

var last_area:int;
var last_x:int;
var last_y:int;

function set_last():void
{
	last_area = bg.cur_area;
	last_x = my.x;
	last_y = my.y;
}

function move_to_last():void
{
	move_area(last_area);
	my.state = my.STATE_STAND;
	my.x = last_x;
	my.y = last_y;
	my.vx = 0;
	my.vy = 0;
}

function move_area(area:int):void
{
	bg.fetch_area(area);
	init_area_enemy();
	ppu.lock();
	ppu.put_in_lock( VRAM_PALETTE+4, &bg.pallet[4], 12 );
	bg.draw_screen();
	ppu.unlock();
}

function move_checkpoint(i:int):void
{
	var cp = &fs.MAP_CHECKPOINT_DATA[fs.MAP_CHECKPOINT[i]];
	my.x = cp[1]+8;
	my.y = cp[2]+8;
	my.vx = 0;
	my.vy = 0;
	var area = cp[0];
	move_area( area );
	set_last();
}

