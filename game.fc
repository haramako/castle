options( bank:0 );

use * from common;
use menu;
use en;
use my;
use debug_menu;
use event;

const PALLET:int[] = incbin("character.chr.dat");

function init_area_enemy():void
{
	anim = 0;
	en.clear();
	
	var n = 0;
	for( n, 0, bg.enemy_num ){
		var idx = n*6;
		var type = bg.enemy[idx];
		var i = en.new();
		if( type & 128 ){
			en.type[i] = en.TYPE_PORTAL;
			en.p4[i] = type & 127;
		}else{
			en.type[i] = type;
		}
		en.px[i] = bg.enemy[idx+1] * 16 + 8;
		en.py[i] = bg.enemy[idx+2] * 16 + 8;
		en.p1[i] = bg.enemy[idx+3];
		en.p2[i] = bg.enemy[idx+4];
		en.p3[i] = bg.enemy[idx+5];
		en.NEW_FUNC[en.type[i]](i);
	}
}


function start(): void
{
	// ppu lock状態で入ってくる
	
	mmc3.set_cbank( 0, 0 );
	mmc3.set_cbank( 1, 2 );
	mmc3.set_cbank( 2, 4 );
	mmc3.set_cbank( 3, 5 );
	mmc3.set_cbank( 4, 6 );
	mmc3.set_cbank( 5, 7 );
	
	ppu.ctrl1_bak = 0b10100000;
	ppu.ctrl2_bak = 0b00011110;
	ppu.scroll1 = 0;
	ppu.scroll2 = 0;

	// パレットの初期化
	ppu.put_in_lock( 0x3f00, PALLET, 32 );

	move_checkpoint(0);

	ppu.unlock();
	
	asm( "cli" );

	anim = 0;

	while( 1 ){
		anim += 1;
		giff = GIFF_TABLE[anim%16];
		
		pad.update();
		en.process();
		my.process();
		my.draw();

		mmc3.set_cbank(0,8+(anim/8)%4*2);
		ppu.wait_vsync();

		// 死亡
		if( my.state == my.STATE_DIE ){
			move_to_last();
		}

		var scroll_dir = -1;
		if( my.x < 8 ){
			scroll_dir = DIR_LEFT;
		}elsif( my.x >= 248 ){
			scroll_dir = DIR_RIGHT;
		}elsif( my.y >= 232 ){
			scroll_dir = DIR_DOWN;
		}elsif( my.y < 8 ){
			scroll_dir = DIR_UP;
		}
		if( scroll_dir != -1 ){
			bg.scroll( scroll_dir );
			set_last();
			init_area_enemy();
		}

		// イベント
		if( game_event ){
			switch( game_event ){
			case event.ID_GET_ITEM:
				event.event_start();
			}
			game_event = 0;
		}
		
		// メニュー
		if( pad.pushed & pad.START ){
			debug_menu.start();
		}elsif( pad.pushed & pad.SELECT ){
			menu.start();
		}
	}
  
}

var last_area:int;
var last_x:int;
var last_y:int;

function set_last():void
{
	last_area = bg.cur_area;
	last_x = my.x;
	last_y = my.y;
}

function move_to_last():void
{
	move_area(last_area);
	my.state = my.STATE_STAND;
	my.x = last_x;
	my.y = last_y;
	my.vx = 0;
	my.vy = 0;
}

function move_area(area:int):void
{
	bg.fetch_area(area);
	init_area_enemy();
	ppu.lock();
	bg.draw_screen();
	ppu.unlock();
}

function move_checkpoint(i:int):void
{
	var cp = &fs.MAP_CHECKPOINT_DATA[fs.MAP_CHECKPOINT[i]];
	my.x = cp[1]+8;
	my.y = cp[2]+8;
	my.vx = 0;
	my.vy = 0;
	var area = cp[0];
	move_area( area );
	set_last();
}
